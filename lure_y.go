// Code generated by goyacc -l -o lure_y.go -p Lure gramma/lure.y. DO NOT EDIT.
package lure

import __yyfmt__ "fmt"

type LureSymType struct {
	yys       int
	boolVal   bool
	intVal    int
	doubleVal float64
	strVal    string
	expr      *Expr
	exprList  *ExprList
}

const TK_AND_LOGIC = 57346
const TK_OR_LOGIC = 57347
const TK_BETWEEN = 57348
const TK_EQ = 57349
const TK_NE = 57350
const TK_GT = 57351
const TK_LT = 57352
const TK_GE = 57353
const TK_LE = 57354
const TK_IN = 57355
const TK_NOT = 57356
const BINOPX = 57357
const TK_AND_KEYWORD = 57358
const TK_NOTIN = 57359
const TK_INT_LITERAL = 57360
const TK_DOUBLE_LITERAL = 57361
const TK_STRING_LITERAL = 57362
const TK_MD5MOD = 57363
const TK_STRCMP = 57364
const TK_IDENTITY_LITERAL = 57365

var LureToknames = [...]string{
	"$end",
	"error",
	"$unk",
	"TK_AND_LOGIC",
	"TK_OR_LOGIC",
	"TK_BETWEEN",
	"TK_EQ",
	"TK_NE",
	"TK_GT",
	"TK_LT",
	"TK_GE",
	"TK_LE",
	"TK_IN",
	"TK_NOT",
	"BINOPX",
	"TK_AND_KEYWORD",
	"TK_NOTIN",
	"TK_INT_LITERAL",
	"TK_DOUBLE_LITERAL",
	"TK_STRING_LITERAL",
	"TK_MD5MOD",
	"TK_STRCMP",
	"TK_IDENTITY_LITERAL",
	"','",
	"'('",
	"')'",
}
var LureStatenames = [...]string{}

const LureEofCode = 1
const LureErrCode = 2
const LureInitialStackSize = 16

var LureExca = [...]int{
	-1, 1,
	1, -1,
	-2, 0,
}

const LurePrivate = 57344

const LureLast = 112

var LureAct = [...]int{

	2, 13, 1, 46, 40, 31, 27, 28, 13, 13,
	43, 42, 26, 13, 29, 30, 14, 5, 33, 34,
	35, 7, 8, 9, 11, 12, 10, 32, 6, 37,
	3, 4, 0, 0, 39, 0, 0, 0, 0, 0,
	0, 0, 45, 44, 18, 19, 17, 20, 21, 22,
	23, 24, 25, 15, 16, 0, 5, 0, 0, 0,
	7, 8, 9, 11, 12, 10, 38, 6, 36, 18,
	19, 17, 20, 21, 22, 23, 24, 25, 15, 16,
	0, 41, 18, 19, 17, 20, 21, 22, 23, 24,
	25, 15, 16, 19, 17, 20, 21, 22, 23, 24,
	25, 15, 16, 17, 20, 21, 22, 23, 24, 25,
	15, 16,
}
var LurePact = [...]int{

	3, -11, 78, -1000, -13, 3, 3, -1000, -1000, -1000,
	-1000, -1000, -1000, 3, 3, -20, 14, 3, 3, 3,
	-1000, -1000, -1000, -1000, -1000, -1000, 42, -1000, 40, 78,
	-1000, 3, -21, 65, 88, 97, -1000, -15, -1000, -16,
	3, 3, -1000, -1000, -23, -1000, -1000,
}
var LurePgo = [...]int{

	0, 31, 0, 30, 2, 16,
}
var LureR1 = [...]int{

	0, 4, 4, 2, 2, 2, 2, 2, 2, 2,
	2, 2, 2, 2, 5, 5, 5, 5, 5, 5,
	3, 3, 3, 3, 1, 1,
}
var LureR2 = [...]int{

	0, 1, 3, 1, 3, 5, 6, 3, 4, 5,
	3, 3, 2, 3, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1,
}
var LureChk = [...]int{

	-1000, -4, -2, -3, -1, 14, 25, 18, 19, 20,
	23, 21, 22, 24, -5, 13, 14, 6, 4, 5,
	7, 8, 9, 10, 11, 12, 25, -2, -2, -2,
	-2, 25, 13, -2, -2, -2, 26, -4, 26, -4,
	25, 16, 26, 26, -4, -2, 26,
}
var LureDef = [...]int{

	0, -2, 1, 3, 0, 0, 0, 20, 21, 22,
	23, 24, 25, 0, 0, 0, 0, 0, 0, 0,
	14, 15, 16, 17, 18, 19, 0, 12, 0, 2,
	4, 0, 0, 0, 10, 11, 7, 0, 13, 0,
	0, 0, 8, 5, 0, 9, 6,
}
var LureTok1 = [...]int{

	1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	25, 26, 3, 3, 24,
}
var LureTok2 = [...]int{

	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23,
}
var LureTok3 = [...]int{
	0,
}

var LureErrorMessages = [...]struct {
	state int
	token int
	msg   string
}{}

/*	parser for yacc output	*/

var (
	LureDebug        = 0
	LureErrorVerbose = false
)

type LureLexer interface {
	Lex(lval *LureSymType) int
	Error(s string)
}

type LureParser interface {
	Parse(LureLexer) int
	Lookahead() int
}

type LureParserImpl struct {
	lval  LureSymType
	stack [LureInitialStackSize]LureSymType
	char  int
}

func (p *LureParserImpl) Lookahead() int {
	return p.char
}

func LureNewParser() LureParser {
	return &LureParserImpl{}
}

const LureFlag = -1000

func LureTokname(c int) string {
	if c >= 1 && c-1 < len(LureToknames) {
		if LureToknames[c-1] != "" {
			return LureToknames[c-1]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func LureStatname(s int) string {
	if s >= 0 && s < len(LureStatenames) {
		if LureStatenames[s] != "" {
			return LureStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func LureErrorMessage(state, lookAhead int) string {
	const TOKSTART = 4

	if !LureErrorVerbose {
		return "syntax error"
	}

	for _, e := range LureErrorMessages {
		if e.state == state && e.token == lookAhead {
			return "syntax error: " + e.msg
		}
	}

	res := "syntax error: unexpected " + LureTokname(lookAhead)

	// To match Bison, suggest at most four expected tokens.
	expected := make([]int, 0, 4)

	// Look for shiftable tokens.
	base := LurePact[state]
	for tok := TOKSTART; tok-1 < len(LureToknames); tok++ {
		if n := base + tok; n >= 0 && n < LureLast && LureChk[LureAct[n]] == tok {
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}
	}

	if LureDef[state] == -2 {
		i := 0
		for LureExca[i] != -1 || LureExca[i+1] != state {
			i += 2
		}

		// Look for tokens that we accept or reduce.
		for i += 2; LureExca[i] >= 0; i += 2 {
			tok := LureExca[i]
			if tok < TOKSTART || LureExca[i+1] == 0 {
				continue
			}
			if len(expected) == cap(expected) {
				return res
			}
			expected = append(expected, tok)
		}

		// If the default action is to accept or reduce, give up.
		if LureExca[i+1] != 0 {
			return res
		}
	}

	for i, tok := range expected {
		if i == 0 {
			res += ", expecting "
		} else {
			res += " or "
		}
		res += LureTokname(tok)
	}
	return res
}

func Lurelex1(lex LureLexer, lval *LureSymType) (char, token int) {
	token = 0
	char = lex.Lex(lval)
	if char <= 0 {
		token = LureTok1[0]
		goto out
	}
	if char < len(LureTok1) {
		token = LureTok1[char]
		goto out
	}
	if char >= LurePrivate {
		if char < LurePrivate+len(LureTok2) {
			token = LureTok2[char-LurePrivate]
			goto out
		}
	}
	for i := 0; i < len(LureTok3); i += 2 {
		token = LureTok3[i+0]
		if token == char {
			token = LureTok3[i+1]
			goto out
		}
	}

out:
	if token == 0 {
		token = LureTok2[1] /* unknown char */
	}
	if LureDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", LureTokname(token), uint(char))
	}
	return char, token
}

func LureParse(Lurelex LureLexer) int {
	return LureNewParser().Parse(Lurelex)
}

func (Lurercvr *LureParserImpl) Parse(Lurelex LureLexer) int {
	var Luren int
	var LureVAL LureSymType
	var LureDollar []LureSymType
	_ = LureDollar // silence set and not used
	LureS := Lurercvr.stack[:]

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	Lurestate := 0
	Lurercvr.char = -1
	Luretoken := -1 // Lurercvr.char translated into internal numbering
	defer func() {
		// Make sure we report no lookahead when not parsing.
		Lurestate = -1
		Lurercvr.char = -1
		Luretoken = -1
	}()
	Lurep := -1
	goto Lurestack

ret0:
	return 0

ret1:
	return 1

Lurestack:
	/* put a state and value onto the stack */
	if LureDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", LureTokname(Luretoken), LureStatname(Lurestate))
	}

	Lurep++
	if Lurep >= len(LureS) {
		nyys := make([]LureSymType, len(LureS)*2)
		copy(nyys, LureS)
		LureS = nyys
	}
	LureS[Lurep] = LureVAL
	LureS[Lurep].yys = Lurestate

Lurenewstate:
	Luren = LurePact[Lurestate]
	if Luren <= LureFlag {
		goto Luredefault /* simple state */
	}
	if Lurercvr.char < 0 {
		Lurercvr.char, Luretoken = Lurelex1(Lurelex, &Lurercvr.lval)
	}
	Luren += Luretoken
	if Luren < 0 || Luren >= LureLast {
		goto Luredefault
	}
	Luren = LureAct[Luren]
	if LureChk[Luren] == Luretoken { /* valid shift */
		Lurercvr.char = -1
		Luretoken = -1
		LureVAL = Lurercvr.lval
		Lurestate = Luren
		if Errflag > 0 {
			Errflag--
		}
		goto Lurestack
	}

Luredefault:
	/* default state action */
	Luren = LureDef[Lurestate]
	if Luren == -2 {
		if Lurercvr.char < 0 {
			Lurercvr.char, Luretoken = Lurelex1(Lurelex, &Lurercvr.lval)
		}

		/* look through exception table */
		xi := 0
		for {
			if LureExca[xi+0] == -1 && LureExca[xi+1] == Lurestate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			Luren = LureExca[xi+0]
			if Luren < 0 || Luren == Luretoken {
				break
			}
		}
		Luren = LureExca[xi+1]
		if Luren < 0 {
			goto ret0
		}
	}
	if Luren == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			Lurelex.Error(LureErrorMessage(Lurestate, Luretoken))
			Nerrs++
			if LureDebug >= 1 {
				__yyfmt__.Printf("%s", LureStatname(Lurestate))
				__yyfmt__.Printf(" saw %s\n", LureTokname(Luretoken))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for Lurep >= 0 {
				Luren = LurePact[LureS[Lurep].yys] + LureErrCode
				if Luren >= 0 && Luren < LureLast {
					Lurestate = LureAct[Luren] /* simulate a shift of "error" */
					if LureChk[Lurestate] == LureErrCode {
						goto Lurestack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if LureDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", LureS[Lurep].yys)
				}
				Lurep--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if LureDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", LureTokname(Luretoken))
			}
			if Luretoken == LureEofCode {
				goto ret1
			}
			Lurercvr.char = -1
			Luretoken = -1
			goto Lurenewstate /* try again in the same state */
		}
	}

	/* reduction by production Luren */
	if LureDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", Luren, LureStatname(Lurestate))
	}

	Lurent := Luren
	Lurept := Lurep
	_ = Lurept // guard against "declared and not used"

	Lurep -= LureR2[Luren]
	// Lurep is now the index of $0. Perform the default action. Iff the
	// reduced production is Îµ, $1 is possibly out of range.
	if Lurep+1 >= len(LureS) {
		nyys := make([]LureSymType, len(LureS)*2)
		copy(nyys, LureS)
		LureS = nyys
	}
	LureVAL = LureS[Lurep+1]

	/* consult goto table to find next state */
	Luren = LureR1[Luren]
	Lureg := LurePgo[Luren]
	Lurej := Lureg + LureS[Lurep].yys + 1

	if Lurej >= LureLast {
		Lurestate = LureAct[Lureg]
	} else {
		Lurestate = LureAct[Lurej]
		if LureChk[Lurestate] != -Luren {
			Lurestate = LureAct[Lureg]
		}
	}
	// dummy call; replaced with literal code
	switch Lurent {

	case 1:
		LureDollar = LureS[Lurept-1 : Lurept+1]
		{
			LureVAL.exprList = exprListOfExpr(LureDollar[1].expr)
		}
	case 2:
		LureDollar = LureS[Lurept-3 : Lurept+1]
		{
			LureVAL.exprList = exprListAppend(LureDollar[1].exprList, LureDollar[3].expr)
		}
	case 3:
		LureDollar = LureS[Lurept-1 : Lurept+1]
		{
			LureVAL.expr = LureDollar[1].expr
		}
	case 4:
		LureDollar = LureS[Lurept-3 : Lurept+1]
		{
			LureVAL.expr = exprBinOp(LureDollar[1].expr, LureDollar[2].intVal, LureDollar[3].expr)
		}
	case 5:
		LureDollar = LureS[Lurept-5 : Lurept+1]
		{
			LureVAL.expr = exprIn(LureDollar[1].expr, TK_IN, LureDollar[4].exprList)
		}
	case 6:
		LureDollar = LureS[Lurept-6 : Lurept+1]
		{
			LureVAL.expr = exprIn(LureDollar[1].expr, TK_NOTIN, LureDollar[5].exprList)
		}
	case 7:
		LureDollar = LureS[Lurept-3 : Lurept+1]
		{
			LureVAL.expr = exprFunction0(LureDollar[1].strVal)
		}
	case 8:
		LureDollar = LureS[Lurept-4 : Lurept+1]
		{
			LureVAL.expr = exprFunction(LureDollar[1].strVal, LureDollar[3].exprList)
		}
	case 9:
		LureDollar = LureS[Lurept-5 : Lurept+1]
		{
			LureVAL.expr = exprBetween(LureDollar[1].expr, LureDollar[3].expr, LureDollar[5].expr)
		}
	case 10:
		LureDollar = LureS[Lurept-3 : Lurept+1]
		{
			LureVAL.expr = exprBinOp(LureDollar[1].expr, LureDollar[2].intVal, LureDollar[3].expr)
		}
	case 11:
		LureDollar = LureS[Lurept-3 : Lurept+1]
		{
			LureVAL.expr = exprBinOp(LureDollar[1].expr, LureDollar[2].intVal, LureDollar[3].expr)
		}
	case 12:
		LureDollar = LureS[Lurept-2 : Lurept+1]
		{
			LureVAL.expr = exprUnaryOp(LureDollar[1].intVal, LureDollar[2].expr)
		}
	case 13:
		LureDollar = LureS[Lurept-3 : Lurept+1]
		{
			LureVAL.expr = LureDollar[2].expr
		}
	case 20:
		LureDollar = LureS[Lurept-1 : Lurept+1]
		{
			LureVAL.expr = exprOfInt(LureDollar[1].intVal)
		}
	case 21:
		LureDollar = LureS[Lurept-1 : Lurept+1]
		{
			LureVAL.expr = exprOfDouble(LureDollar[1].doubleVal)
		}
	case 22:
		LureDollar = LureS[Lurept-1 : Lurept+1]
		{
			LureVAL.expr = exprOfString(LureDollar[1].strVal)
		}
	case 23:
		LureDollar = LureS[Lurept-1 : Lurept+1]
		{
			LureVAL.expr = exprOfIdentity(LureDollar[1].strVal)
		}
	}
	goto Lurestack /* stack new state and value */
}
